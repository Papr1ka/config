## Работа 2

Реализовать свою мини-версию Make.

Для описания задач, зависимостей и команд можно использовать язык реализации (если это скриптовый язык в духе Питона) или же реализовать собственный язык с помощью средств из ДЗ 3. Если у вас нет хороших идей на этот счет, то используем синтаксис make, но позволяем отступы делать "по-человечески", а не только с помощью "\t".

Для определения порядка выполнения задач должен использоваться алгоритм топологической сортировки. Уже выполненные задачи повторно не выполняются.

Для определения изменений в зависимостях задач (файлах и других видах данных) необходимо использовать не время изменения файла, а хеш-значения, см. https://medium.com/@buckaroo.pm/build-systems-should-use-hashes-over-timestamps-54d09f6f2c4

Обратите внимание, вам нужно хешировать содержимое файлов. То есть для хранения аналога файловой системы с информацией о файлах вполне можно использовать тот же JSON-объект, а вот хешировать сами данные лучше чем-нибудь проверенным, с малой вероятностью коллизий. Посмотрите стандартную библиотеку. Для Питона это https://docs.python.org/3/library/hashlib.html

Проверить работоспособность реализованной системы автоматизации сборки на примере civgraph (том варианте, где создаются файлы!), а также на собственном примере компиляции приложения.

Иными словами, идеальное решение подразумевает настоящую, пусть и примитивную, систему сборки, которая работала бы с реальными файлами и произвольными командами, а также включала в себя БД в каком-то виде для хранения состояния между запусками.

## Особенности

- разработана грамматика [тут](./auto/grammar.txt), является подмножеством грамматики Python, синтаксические ошибки подсвечиваются
- используется библиотека Python - ast
- реализованы цели, зависимости, произвольные скрипты для bash или другой встроенной оболочки в OS
- используется алгоритм шифрования sha256
- циклы пропускаются
- поддерживается визуализация графа зависимостей
- поддерживается вывод списка очерёдности выполнения задач
- из файла строится программная утилита
- поддерживает считывание зависимостей из json, правда без команд

Данный проект является библиотекой и позволяет быстро создать новые сценарии

Пример:

Библиотека в скромной мере покрыта комментариями, где можно узнать значение некоторых параметров, например print_taskts и mock_name для auto.configure

```python
import auto # библиотека


# noinspection PyStatementEffect
@auto.cli # добавляет поддержку cli интерфейса
@auto.view # если необходимо визуализировать граф зависимостей
@auto.configure(print_tasks=False, mock_name="demo.json") # данный декоратор парсит грамматику и формирует класс обработчик зависимостей, который используют декораторы выше
def test():
    # "задача" <= ("зависимость1", "зависимость2", ...)
    # [
    #   "команда1",
    #   "команда2"
    #   ...
    # ]
    # ! если между "командой1" и "комадной2" не будет запятой, они превратятся в "команду1+команду2"

    # далее у нас есть цикл, но система его распознает
    "test" <= "test2"
    ['echo "test"']

    "test2" <= ("test3")
    ['echo "test2"']

    "test3" <= ("test")
    ['echo "test3"']

    # следующая цель без зависимостей и это указано явно
    "sw"
    [
        'echo Hello there!',
        'sleep 2',
        'echo "Oops! I fell asleep for a couple seconds!"'
    ]
```

Имя фунции неважно, вызывать функцию не нужно, она будет запущена декоратором cli.

## Структура проекта

- `./auto` - библиотека
- `./civgraph` - папка для работы с задачами, заданными через json
- `./civgraph.json` - тестовый набор зависимостей
- `./practice` - реальный пример сборки проекта на c++
- `./make.py` - тестовый пример сборки различных задач

## Зависимости:

- `python3`
- `graphviz` + зависимости для graphviz как утилиты для os (если есть желание сразу видеть граф, а не получать файл .dot)
- `sstack` - кастомный стек, написан на c разработчиком данного проекта, приносит радость тем и используется для топологической сортировки, доступен в [тестовом репозитории PyPi](https://test.pypi.org/project/sstack/0.0.1/), если установка не получается, следует установить `python3-devel`, в Fedora это можно сделать через `dnf install python3-devel`.

- `python 3.11.6` в момент тестирования

## Как запустить:

- `python make.py -h` - вывод справки, поддерживается не только справка, но об этом в справке

## Стоит учесть

Механизм следующий:

любая цель изначально рассматривается как файл, если файл найден, он хэшируется и свежая хэш-сумма сравнивается с той, которая хранится в базе данных .json, если хэш разный, значит задача будет переделана (только 1 раз), а вместе с ней и все те задачи, в списках которых она числится как зависимость, если же хэш одинаковый, то задача переделана не будет. Если файл не найден, цель рассматривается абстрактно и всегда будет сделана.


Построй свой make.py, это очень просто!
